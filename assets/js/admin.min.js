($=>{window.TokenicoProviders||(window.TokenicoProviders={});{const evm={errorCatch:error=>(console.error(error),ongoingProcessEnded(),"object"!=typeof error?"request-rejected"==error?infoPopup(Tokenico.lang.requestRejected):errorPopup("token-balance-not-enough"==error?Tokenico.lang.saleBalanceError:Tokenico.lang.invalidTokenAddress):4001==error.code?infoPopup(Tokenico.lang.requestRejected):-32603==error.code?infoPopup(Tokenico.lang.intrinsicGasTooLow):error.message.includes("not pay the presale publish fee")?infoPopup(Tokenico.lang.youDidintPay):error.message.includes("have already created a presale")?infoPopup(Tokenico.lang.youHaveAlreadyCreated):error.message.includes("insufficient funds for gas")||error.message.includes("Invalid number of parameters for")||error.message.includes('missing revert data (action="estimateGas"')?infoPopup(Tokenico.lang.insufficientBalance):void errorPopup(Tokenico.lang.unexpectedError)),getConnectedAddress:()=>evm.provider.connectedWallet.connectedAccount,connect:async network=>(Tokenico.tryConnecting="MetaMask",evm.provider=new EvmChains({network:network}),evm.provider.connectWallet("metamask")),getBalance:async()=>evm.provider.Coin().getBalance(evm.getConnectedAddress()),getTokenBalance:async address=>evm.provider.Token(address).getBalance(evm.getConnectedAddress()),getTokenMetaData:async address=>{address=evm.provider.Token(address);return{name:await address.getName(),symbol:await address.getSymbol(),address:await address.getAddress(),decimals:await address.getDecimals(),totalSupply:await address.getTotalSupply()}},getNotEndedPresales:async(networkId,contractAddress,contractAbi)=>{contractAddress=await evm.provider.Contract(contractAddress,contractAbi).call("getNotEndedPresales",[evm.getConnectedAddress()]);let decimals=Tokenico.networks[networkId].nativeCurrency.decimals;return contractAddress.map(item=>({presaleKey:item.presaleId??item.presaleKey,receiverAddress:item.receiverAddress,tokenAddress:item.tokenAddress,maxContribution:EvmChains.utils.toDec(item.maxContribution,decimals),minContribution:EvmChains.utils.toDec(item.minContribution,decimals),totalSaleLimit:EvmChains.utils.toDec(item.totalSaleLimit,decimals),totalSales:EvmChains.utils.toDec(item.totalSales,decimals),exchangeRate:parseInt(item.exchangeRate),startDate:item.startDate,endDate:item.endDate,instantTransfer:item.instantTransfer}))},calculateTokenNewApprove:async(networkId,tokenAddress,contractAddress,contractAbi)=>{networkId=(await evm.getNotEndedPresales(networkId,contractAddress,contractAbi)).filter(item=>item.tokenAddress==tokenAddress);let totalTokensBeSold=0;return networkId.forEach(item=>{totalTokensBeSold+=(item.totalSaleLimit-item.totalSales)*item.exchangeRate}),totalTokensBeSold},publish:async(contractAddress,contractAbi,args)=>new Promise(async(resolve,reject)=>{try{waitingPopup(Tokenico.lang.presalePublish);var contract=evm.provider.Contract(contractAddress,contractAbi);try{if(await contract.call("getPresale",[args[0]]))return resolve(!0)}catch(error){}var from=evm.getConnectedAddress(),decimals=evm.provider.network.nativeCurrency.decimals,publishFee=EvmChains.utils.toHex(.1,decimals),data=contract.getData("publish",args),gas=await contract.getEstimateGas("publish",args,{value:publishFee,from:from});return evm.provider.connectedWallet.sendTransaction([{to:contractAddress,value:publishFee,from:from,gas:gas,data:data}]).then(transactionHash=>{transactionHash=evm.provider.Transaction(transactionHash);waitingPopup(Tokenico.lang.publishProcess,`${Tokenico.lang.transactionId} <a href="${transactionHash.getUrl()}" target="_blank">${transactionHash.hash}</a>`),transactionHash.validate(5).then(async()=>{resolve(!0)}).catch(error=>{evm.errorCatch(error),reject(!1)})}).catch(error=>{evm.errorCatch(error),reject(!1)})}catch(error){evm.errorCatch(error),reject(!1)}}),approve:async(totalTokensBeSold,tokenAddress,contractAddress)=>new Promise(async(resolve,reject)=>{try{var token=evm.provider.Token(tokenAddress),connectedAddress=evm.getConnectedAddress();if(await evm.getTokenBalance(tokenAddress)<totalTokensBeSold)return evm.errorCatch("token-balance-not-enough"),reject(!1);waitingPopup(Tokenico.lang.saleApprove);var allowance=await token.allowance(connectedAddress,contractAddress);if(totalTokensBeSold<=allowance)return resolve(!0);var data=await token.approve(connectedAddress,contractAddress,totalTokensBeSold);evm.provider.connectedWallet.sendTransaction(data).then(transactionHash=>{transactionHash=evm.provider.Transaction(transactionHash);waitingPopup(Tokenico.lang.approveProcess,`${Tokenico.lang.transactionId} <a href="${transactionHash.getUrl()}" target="_blank">${transactionHash.hash}</a>`),transactionHash.validate(5).then(async()=>{resolve(!0)}).catch(error=>{evm.errorCatch(error),reject(!1)})}).catch(error=>{evm.errorCatch(error),reject(!1)})}catch(error){evm.errorCatch(error),reject(!1)}}),deployContract:(abi,byteCode)=>new Promise(async(resolve,reject)=>{waitingPopup(Tokenico.lang.contractDeployMsg);try{var provider=new ethers.providers.Web3Provider(window.ethereum),contract=await new ethers.ContractFactory(abi,byteCode,provider.getSigner()).deploy(),hash=contract.deployTransaction.hash,tx=evm.provider.Transaction(hash);waitingPopup(Tokenico.lang.deployContract,`${Tokenico.lang.transactionId} <a href="${tx.getUrl()}" target="_blank">${hash}</a>`),await contract.deployTransaction.wait(),resolve(contract.address)}catch(error){evm.errorCatch(error),reject(!1)}}),unDeployedCondition:options=>new Promise(async(resolve,reject)=>{Tokenico.getDeployedContract(options.networkId,options.version)?resolve(!0):(await Swal.fire({title:Tokenico.lang.notDeployedInThisNetwork,icon:"info",showCancelButton:!0,confirmButtonColor:"#3085d6",cancelButtonColor:"#d33",confirmButtonText:Tokenico.lang.deploy,cancelButtonText:Tokenico.lang.cancel})).isConfirmed?evm.deployContract(options.abi,options.byteCode).then(contractAddress=>{Tokenico.setDeployedContract(options.networkId,options.version,contractAddress).then(()=>{resolve(!0)}).catch(()=>{reject(!1)})}).catch(()=>{reject(!1)}):reject(!1)}),startProcess:async(options,callback)=>{try{var tokenAddress,contractAddress,decimals;return await evm.unDeployedCondition(options)?await evm.getBalance()<.1?callback("balance"):(tokenAddress=options.args.tokenAddress,contractAddress=Tokenico.getDeployedContract(options.networkId,options.version),decimals=options.network.nativeCurrency.decimals,options.args.totalSaleLimit=EvmChains.utils.toHex(options.args.totalSaleLimit,decimals),options.args.minContribution=EvmChains.utils.toHex(options.args.minContribution,decimals),options.args.maxContribution=EvmChains.utils.toHex(options.args.maxContribution,decimals),await evm.publish(contractAddress,options.abi,Object.values(options.args))?await evm.approve(options.totalTokensBeSold,tokenAddress,contractAddress)?void callback(!0):callback("approve"):callback("publish")):callback("deploy")}catch(error){callback(error)}}};window.TokenicoProviders.evm=evm}(()=>{const tron={},tronLink=window.tronLink;tron.errorCatch=error=>{if(console.error(error),error=(error=>{if("Cannot transfer TRX to the same account"==error)return"same-account";if("object"==typeof error){if("WalletSignTransactionError"==error.name||String(error.message).includes("Confirmation declined by user")||String(error.message).includes("User rejected the request.")||String(error.message).includes("The user rejected connection.")||String(error.message).includes("Modal is closed.")||String(error.message).includes("User canceled")||String(error.message).includes("User rejected"))return"request-rejected";if(String(error.message).includes("The wallet is not found."))return"wallet-not-found";if(String(error.message).includes("User disapproved requested chains"))return"not-accepted-chain";if(error.message.includes("The QR window is closed."))return"closed-walletconnect-modal"}else if("string"==typeof error&&error.includes("Confirmation declined by user"))return"request-rejected";return error})(error),ongoingProcessEnded(),"object"!=typeof error)return"request-rejected"==error?infoPopup(Tokenico.lang.requestRejected):errorPopup("token-balance-not-enough"==error?Tokenico.lang.saleBalanceError:Tokenico.lang.invalidTokenAddress);errorPopup(Tokenico.lang.unexpectedError)},tron.connect=async network=>{if(Tokenico.tryConnecting="TronLink",!tronLink)throw"wallet-not-found";var result=await tronLink.request({method:"tron_requestAccounts"});if(!result)throw"locked-wallet";if(4001==result.code)throw"request-rejected";if(network.testnet||"https://api.nileex.io"!=tronLink.tronWeb.fullNode.host)return!0;throw"not-accepted-chain"},tron.getConnectedAddress=()=>tronLink.tronWeb.defaultAddress.base58,tron.getBalance=async address=>parseFloat(tronLink.tronWeb.fromSun(await tronLink.tronWeb.trx.getBalance(address))),tron.getTokenMetaData=async address=>{let token=await tronLink.tronWeb.contract().at(address),decimals=parseFloat((await token.decimals().call()).toString(10));var totalSupply=parseFloat((await token.totalSupply().call()).toString(10));"0".repeat(decimals);return{address:address,decimals:decimals,name:await token.name().call(),symbol:await token.symbol().call(),totalSupply:totalSupply/10**decimals,allowance:async(owner,spender)=>{owner=(await token.allowance(owner,spender).call()).toString(10);return parseFloat(BigInt(owner)/10n**BigInt(decimals))},getBalance:async address=>{address=(await token.balanceOf(address).call()).toString(10);return parseFloat(BigInt(address)/10n**BigInt(decimals))}}},tron.getTokenBalance=async(address,tokenAddress)=>{return(await tron.getTokenMetaData(tokenAddress)).getBalance(address)},tron.waitTransaction=async transactionHash=>{try{var data=await tronLink.tronWeb.trx.getTransaction(transactionHash);data.info=await tronLink.tronWeb.trx.getTransactionInfo(transactionHash);let result=null;return data.ret[0]&&"REVERT"==data.ret[0]?.contractRet?(errorPopup(Tokenico.lang.transactionReverted,`${Tokenico.lang.transactionId} <a href="${tron.getTransactionUrl(transactionHash)}" target="_blank">${transactionHash}</a>`),!1):"boolean"==typeof(result=data.info&&data.info.blockNumber?"REVERT"!=data.ret[0].contractRet&&"FAILED"!=data.info.result:result)?result:(await new Promise(r=>setTimeout(r,3e3)),tron.waitTransaction(transactionHash))}catch(error){return tron.errorCatch(error),!1}},tron.signAndSendTransaction=async transaction=>new Promise(async resolve=>{try{var signedTransaction=await tronLink.tronWeb.trx.sign(transaction),txid=(await tronLink.tronWeb.trx.sendRawTransaction(signedTransaction))["txid"];resolve(txid)}catch(error){tron.errorCatch(error)}}),tron.createTransaction=async(contractAddress,functions,options,parameters,from)=>tronLink.tronWeb.transactionBuilder.triggerSmartContract(contractAddress,functions,options,parameters,from),tron.deployContract=async options=>(waitingPopup(Tokenico.lang.contractDeployMsg),new Promise(async(resolve,reject)=>{try{var tx=await tronLink.tronWeb.transactionBuilder.createSmartContract(options,tron.getConnectedAddress()),result=await tronLink.tronWeb.trx.sign(tx);return resolve(await tronLink.tronWeb.trx.sendRawTransaction(result))}catch(error){tron.errorCatch(error),reject(!1)}})),tron.getTransactionUrl=transactionHash=>{let explorerUrl=tron.network.explorerUrl;return(explorerUrl+=explorerUrl.endsWith("/")?"":"/")+"transaction/"+transactionHash},tron.unDeployedCondition=options=>new Promise(async(resolve,reject)=>{Tokenico.getDeployedContract(options.networkId,options.version)?resolve(!0):(await Swal.fire({title:Tokenico.lang.notDeployedInThisNetwork,icon:"info",showCancelButton:!0,confirmButtonColor:"#3085d6",cancelButtonColor:"#d33",confirmButtonText:Tokenico.lang.deploy,cancelButtonText:Tokenico.lang.cancel})).isConfirmed?tron.deployContract({name:"TokenICO",abi:options.abi,bytecode:options.byteCode,feeLimit:2e9,callValue:0,userFeePercentage:100,originEnergyLimit:2e6,parameters:[]}).then(async result=>{var transactionHash=result.transaction.txID,result=result.transaction.contract_address;waitingPopup(Tokenico.lang.deployContract,`${Tokenico.lang.transactionId} <a href="${tron.getTransactionUrl(transactionHash)}" target="_blank">${transactionHash}</a>`),await tron.waitTransaction(transactionHash)&&Tokenico.setDeployedContract(options.networkId,options.version,tronLink.tronWeb.address.fromHex(result)).then(()=>{resolve(!0)}).catch(()=>{reject(!1)})}).catch(()=>{reject(!1)}):reject(!1)}),tron.publish=async(contractAddress,abi,args)=>{try{waitingPopup(Tokenico.lang.presalePublish);var parameter=[{type:"string",value:args.presaleKey},{type:"address",value:args.tokenAddress},{type:"uint256",value:args.totalSaleLimit},{type:"uint256",value:args.minContribution},{type:"uint256",value:args.maxContribution},{type:"uint256",value:args.exchangeRate},{type:"uint256",value:args.startDate},{type:"uint256",value:args.endDate},{type:"bool",value:args.instantTransfer}],options={feeLimit:2e8,callValue:tronLink.tronWeb.toSun(500)},transaction=(await tron.createTransaction(contractAddress,"publish(string,address,uint256,uint256,uint256,uint256,uint256,uint256,bool)",options,parameter,tron.getConnectedAddress()))["transaction"],transactionHash=await tron.signAndSendTransaction(transaction);return waitingPopup(Tokenico.lang.publishProcess,`${Tokenico.lang.transactionId} <a href="${tron.getTransactionUrl(transactionHash)}" target="_blank">${transactionHash}</a>`),await tron.waitTransaction(transactionHash)?!0:!1}catch(error){return tron.errorCatch(error),!1}},tron.approve=async(totalTokensBeSold,tokenAddress,contractAddress)=>{try{var parameter,options,transaction,transactionHash,meta=await tron.getTokenMetaData(tokenAddress),connectedAddress=tron.getConnectedAddress();return await meta.getBalance(connectedAddress)<totalTokensBeSold?(tron.errorCatch("token-balance-not-enough"),!1):(waitingPopup(Tokenico.lang.saleApprove),totalTokensBeSold<=await meta.allowance(connectedAddress,contractAddress)||(parameter=[{type:"address",value:contractAddress},{type:"uint256",value:tronLink.tronWeb.toHex(totalTokensBeSold*10**meta.decimals)}],options={feeLimit:1e8},transaction=(await tron.createTransaction(tokenAddress,"approve(address,uint256)",options,parameter,connectedAddress))["transaction"],transactionHash=await tron.signAndSendTransaction(transaction),waitingPopup(Tokenico.lang.approveProcess,`${Tokenico.lang.transactionId} <a href="${tron.getTransactionUrl(transactionHash)}" target="_blank">${transactionHash}</a>`),!!await tron.waitTransaction(transactionHash)))}catch(error){return tron.errorCatch(error),!1}},tron.startProcess=async(options,callback)=>{try{var contractAddress;return(tron.network=options.network,await tron.getBalance()<500)?callback("balance"):await tron.unDeployedCondition(options)?(contractAddress=Tokenico.getDeployedContract(options.networkId,options.version),options.args.totalSaleLimit=tronLink.tronWeb.toSun(options.args.totalSaleLimit),options.args.minContribution=tronLink.tronWeb.toSun(options.args.minContribution),options.args.maxContribution=tronLink.tronWeb.toSun(options.args.maxContribution),await tron.publish(contractAddress,options.abi,options.args)?await tron.approve(options.totalTokensBeSold,options.args.tokenAddress,contractAddress)?void callback(!0):callback("approve"):callback("publish")):callback("deploy")}catch(error){return callback(error)}},window.TokenicoProviders.tron=tron})();{const solana={},mcSolana=window.MultipleChain.Solana,{SolanaProvider,AnchorProgram}=window.SolanaProvider;solana.errorCatch=error=>{if(console.error(error),error=(error=>{if("object"==typeof error){if(error.message.includes("QR Code Modal Closed"))return"closed-walletconnect-modal";if("WalletSendTransactionError"==error.name&&(-1<String(error.message).indexOf("Unexpected error")||-1<String(error.message).indexOf("Transaction simulation failed: Blockhash not found")||-1<String(error.message).indexOf("Transaction results in an account (1) without insufficient funds for rent")))return error;if(["WalletConnectionError","WalletWindowClosedError","WalletAccountError","WalletSendTransactionError"].includes(error.name)||4001==error.code||"User rejected the request."==error.message||"WalletSignTransactionError"==error.name||-1<String(error.message).indexOf("user reject this request")||"User canceled request"==error.message)return"request-rejected";if("WalletTimeoutError"==error.name)return"timeout";if(error.message&&-1!==error.message.indexOf("403")||error.message&&-1!==error.message.indexOf("Access forbidden"))return"rpc-access-forbidden";if("WalletNotReadyError"==error.name)return"wallet-not-found";if("WalletSendTransactionError"==error.name&&("User rejected the request."!=error.message||"User canceled request"!=error.message)||"User disapproved requested chains"==error.message)return"not-accepted-chain"}return error})(error),ongoingProcessEnded(),"object"!=typeof error)return"request-rejected"==error?infoPopup(Tokenico.lang.requestRejected):errorPopup("token-balance-not-enough"==error?Tokenico.lang.saleBalanceError:Tokenico.lang.invalidTokenAddress);errorPopup(Tokenico.lang.unexpectedError)},solana.connect=async network=>{Tokenico.tryConnecting="Phantom";network={rpcUrl:network.rpcUrl,testnet:Boolean(network.testnet)};return solana.provider=new SolanaProvider(network),solana.provider.connectWallet("phantom")},solana.getConnectedAddress=()=>solana.provider.connectedWallet.connectedAccount,solana.getBalance=async()=>solana.provider.Coin().getBalance(solana.getConnectedAddress()),solana.tokenInstance=address=>new mcSolana.assets.Token(address,solana.provider),solana.getTokenMetaData=async address=>{address=solana.tokenInstance(address);return{name:await address.getName(),symbol:await address.getSymbol(),address:await address.getAddress(),decimals:await address.getDecimals(),totalSupply:await address.getTotalSupply()}},solana.startProcess=async(options,callback)=>{try{if(await solana.getBalance()<.503)return callback("balance");var tokenProgram=options.tokenProgram,tokenAddress=options.args.tokenAddress;let connectedWallet=solana.provider.connectedWallet;var walletAdapter=connectedWallet.solWalletAdapter.wallet.value.adapter,programId=Tokenico.getDeployedContract(options.networkId,options.version);if(solana.program=new AnchorProgram(options.abi,programId,solana.provider.web3,walletAdapter),await solana.tokenInstance(tokenAddress).getBalance(solana.getConnectedAddress())<options.totalTokensBeSold)return solana.errorCatch("token-balance-not-enough");waitingPopup(Tokenico.lang.presalePublish);solana.program.createPresaleTransaction(options.args.presaleKey,{totalSaleLimit:options.args.totalSaleLimit,minContribution:options.args.minContribution,maxContribution:options.args.maxContribution,exchangeRate:options.args.exchangeRate,totalSales:0,startDate:options.args.startDate,endDate:options.args.endDate,instantTransfer:options.args.instantTransfer},{tokenAddress:tokenAddress,tokenProgram:tokenProgram}).then(async({transaction,presaleAccount})=>{Tokenico.addNetworkArguments({presaleAccount:presaleAccount}),(async transaction=>{transaction=await connectedWallet.sendTransaction(transaction),transaction=solana.provider.Transaction(transaction);return waitingPopup(Tokenico.lang.publishProcess,`${Tokenico.lang.transactionId} <a href="${transaction.getUrl()}" target="_blank">${transaction.hash}</a>`),transaction.validate()})(transaction).then(()=>{callback(!0)}).catch(solana.errorCatch)}).catch(solana.errorCatch)}catch(error){callback(error)}},window.TokenicoProviders.solana=solana}Tokenico.providers=TokenicoProviders;let willNotBeChecked=["key","args","token","network","totalSales","remainingLimit","contractAddress","contractVersion"];function infoPopup(message,html=null){return Swal.fire({title:message,html:html,icon:"info",didOpen:()=>{Swal.hideLoading()}})}function errorPopup(message,html=null){return Swal.fire({title:message,html:html,icon:"error",didOpen:()=>{Swal.hideLoading()}})}function waitingPopup(title,html=null){Swal.fire({title:title,html:html,allowOutsideClick:!1,didOpen:()=>{Swal.showLoading()}})}function ongoingProcessEnded(){window.onbeforeunload=!1}willNotBeChecked.forEach(val=>{$("[name='tokenicoPresaleData["+val+"]']").closest(".csf-field").css("display","none")}),"publish"==Tokenico.presaleStatus&&($(".csf-section input, .csf-section select").attr("disabled","disabled"),$(".csf-section .csf--switcher").closest(".csf-fieldset").prepend("<div class='disabled'></div>"),$(".important-note-content").css("display","none")),"publish"==Tokenico.presaleStatus&&$("#submitdiv").remove(),Tokenico.getDeployedContract=(networkId,version)=>Tokenico.deployedContracts[networkId]&&Tokenico.deployedContracts[networkId][version]?Tokenico.deployedContracts[networkId][version]:null,Tokenico.setDeployedContract=(networkId,version,address)=>new Promise((resolve,reject)=>{Tokenico.deployedContracts[networkId]||(Tokenico.deployedContracts[networkId]={}),Tokenico.deployedContracts[networkId][version]=address,$("[name='tokenicoPresaleData[contractVersion]']").val(version),$("[name='tokenicoPresaleData[contractAddress]']").val(address),$.ajax({method:"POST",url:Tokenico.apiUrl+"/save-deployed-contract",data:{version:version,address:address,networkId:networkId},complete(){resolve(!0)},error(){reject(!1)}})}),Tokenico.addNetworkArguments=args=>{var dataEl=$("[name='tokenicoPresaleData[args]']"),oldArgs=JSON.parse(dataEl.val()?dataEl.val():"{}");dataEl.val(JSON.stringify(Object.assign(args,oldArgs)))};const errorPopupMap=error=>{"wallet-not-found"==error?infoPopup(Tokenico.lang.walletNotDetected.replace("{wallet}",Tokenico.tryConnecting)):"already-processing"==error?infoPopup(Tokenico.lang.alreadyProcessing):"not-accepted-wallet"==error?infoPopup(Tokenico.lang.notAcceptedWallet):errorPopup("not-accepted-chain"==error?Tokenico.lang.notAcceptedChain:"request-rejected"==error?Tokenico.lang.connectionRejected:"invalid-token-address"==error?Tokenico.lang.invalidTokenAddress:"invalid-date"==error?Tokenico.lang.getDatesError:"big-min-max-contribution"==error?Tokenico.lang.bigMinMaxContribution:"big-min-contribution"==error?Tokenico.lang.bigMinContribution:"big-start-date"==error?Tokenico.lang.bigStartDate:"start-date-less-from-now"==error?Tokenico.lang.startDateLessFromNow:"deploy"==error?Tokenico.lang.deployError:"approve"==error?Tokenico.lang.approveError:"publish"==error?Tokenico.lang.publishError:"balance"==error?Tokenico.lang.balanceError:"less-min-contribution-amount"==error?Tokenico.lang.lessMinContributionAmount:"no-abi-found"==error?Tokenico.lang.noAbiFound:"no-bytecode-found"==error?Tokenico.lang.noBytecodeFound:"locked-wallet"==error?Tokenico.lang.lockedWallet:Tokenico.lang.unexpectedError)};$(document).on("click",".tico-update-desc",function(e){e.preventDefault();var e=tinymce.activeEditor.getContent(),title=$("[name='post_title']").val(),postId=$(this).data("post-id");$.ajax({method:"POST",url:Tokenico.apiUrl+"/update-description",data:{title:title,content:e,postId:postId},beforeSend(){waitingPopup(Tokenico.lang.pleaseAcceptReloadPage)},success(response){response.success?window.location.reload():errorPopup(response.message)},error(){errorPopup(Tokenico.lang.unexpectedError)}})});let published=!1,selectedNetwork;$("#post").submit(async function(e){try{var clickedEl=e.originalEvent.submitter,publishBtn=$("[name='publish']")[0];if(clickedEl==publishBtn&&1!=published){if(e.preventDefault(),!1===await new Promise((resolve,reject)=>{$.each($(".csf-field input"),(key,element)=>{var val=$(element).val(),id=$(element).attr("data-depend-id");if(!val&&!willNotBeChecked.includes(id))return val=$(element).closest(".csf-field").find(".csf-title h4").html(),errorPopup(Tokenico.lang.fieldCannotBeEmpty.replace("%s",val)),reject(!1)}),resolve(!0)}))return!1;var networkId=$(".csf-field select[data-depend-id='networkId']").val(),tokenAddress=$(".csf-field input[data-depend-id='tokenAddress']").val().trim(),totalSaleLimit=parseInt($(".csf-field input[data-depend-id='totalSaleLimit']").val()),minContribution=parseFloat($(".csf-field input[data-depend-id='minContribution']").val()),maxContribution=parseFloat($(".csf-field input[data-depend-id='maxContribution']").val()),exchangeRate=parseInt($(".csf-field input[data-depend-id='exchangeRate']").val());let startDate=$(".csf-field input[data-depend-id='startDate']").val(),endDate=$(".csf-field input[data-depend-id='endDate']").val();var instantTransfer=1==$(".csf-field input[data-depend-id='instantTransfer']").val(),tokenProgram=$(".csf-field select[data-depend-id='tokenProgram']").val().trim(),totalTokensBeSold=totalSaleLimit*exchangeRate;if($(".csf-field input[data-depend-id='remainingLimit']").val(totalSaleLimit),$("[name='tokenicoPresaleData[exchangeRate]']").val(exchangeRate),$("[name='tokenicoPresaleData[totalSaleLimit]']").val(totalSaleLimit),totalSaleLimit<minContribution||totalSaleLimit<maxContribution)throw"big-min-max-contribution";if(maxContribution<minContribution)throw"big-min-contribution";if(minContribution*exchangeRate<1)throw"less-min-contribution-amount";var dateParts=startDate.split(/[-T:]/).map(parseFloat),timestamp=Date.UTC(dateParts[0],dateParts[1]-1,dateParts[2],dateParts[3],dateParts[4]);if(Math.floor(timestamp/1e3)<Math.floor(Date.now()/1e3))throw"start-date-less-from-now";if(startDate>endDate)throw"big-start-date";var presaleKey=Tokenico.key,network=Tokenico.networks[networkId],contract=Tokenico.contracts[network.code],provider=Tokenico.providers[network.code];if(!provider)return errorPopup("Provider not found");if(void 0!==network.rpcUrl&&!Boolean(network.rpcUrl))return errorPopup(Tokenico.lang.pleaseEnterRpc);if(selectedNetwork!=networkId){if(!1===(networkName=network.name,await new Promise((resolve,reject)=>{Swal.fire({title:Tokenico.lang.confirmNetwork.replace("%s",networkName),icon:"info",showCancelButton:!0,confirmButtonColor:"#3085d6",cancelButtonColor:"#d33",confirmButtonText:Tokenico.lang.confirm,cancelButtonText:Tokenico.lang.cancel}).then(result=>{result.isConfirmed?resolve(!0):reject(!1)})})))return!1;selectedNetwork=networkId}waitingPopup(Tokenico.lang.waitingForTimeCreation);var result=await function(startDate,endDate,networkId){return new Promise((resolve,reject)=>{$.ajax({method:"GET",url:Tokenico.apiUrl+"/get-dates",data:{endDate:endDate,startDate:startDate,networkId:networkId},success(response){var startDate,endDate;response.success?(startDate=response.data.startDate,endDate=response.data.endDate,resolve({startDate:startDate,endDate:endDate})):errorPopup(response.message)},error(){console.error("Error while getting dates"),reject(!1)}})})}(startDate,endDate,networkId);if(!result)throw"invalid-date";startDate=result.startDate,endDate=result.endDate;var version=contract.version,abi=contract[version],byteCode=contract.byteCode,address=Tokenico.getDeployedContract(networkId,version);if(!abi)throw"no-abi-found";if(!byteCode&&"evm"==network.code)throw"no-bytecode-found";$("[name='tokenicoPresaleData[key]']").val(presaleKey),$("[name='tokenicoPresaleData[contractVersion]']").val(version),$("[name='tokenicoPresaleData[contractAddress]']").val(address),$("[name='tokenicoPresaleData[network]']").val(JSON.stringify(network)),window.onbeforeunload=()=>"There is an ongoing process, please do not close the browser.",waitingPopup(Tokenico.lang.waitingConnection);var res=await provider.connect(network).catch(error=>{throw error});if(Swal.close(),!1===res)return!1;waitingPopup(Tokenico.lang.pleaseWait);try{var tokenMetaData=await provider.getTokenMetaData(tokenAddress);$("[name='tokenicoPresaleData[token]']").val(JSON.stringify(tokenMetaData))}catch(e){throw console.error(e),"invalid-token-address"}var options={abi:abi,network:network,version:version,byteCode:byteCode,networkId:networkId,tokenProgram:tokenProgram,totalTokensBeSold:totalTokensBeSold,args:{presaleKey:presaleKey,tokenAddress:tokenAddress,totalSaleLimit:totalSaleLimit,minContribution:minContribution,maxContribution:maxContribution,exchangeRate:exchangeRate,startDate:startDate,endDate:endDate,instantTransfer:instantTransfer}};provider.startProcess(options,noError=>{if(ongoingProcessEnded(),!0===noError)published=!0,message=Tokenico.lang.presalePublished,html=null,Swal.fire({title:message,html:html,icon:"success",didOpen:()=>{Swal.hideLoading()}}).then(()=>{var div;(div=document.createElement("div")).className+="overlay",div.style.backgroundColor="#EFEFEF",div.style.position="fixed",div.style.width="100%",div.style.height="100%",div.style.zIndex="500",div.style.top="0px",div.style.left="0px",div.style.opacity=".5",document.body.appendChild(div),$("[name='publish']").click(),waitingPopup(Tokenico.lang.redirecting)});else{console.log(noError);message=noError;if(!1===message)return!1;errorPopupMap(message)}var message,html})}}catch(error){if(ongoingProcessEnded(),console.error(error),!1===error)return!1;if("string"==typeof error)errorPopupMap(error);else{let data;error.message.includes("Internal JSON-RPC error.")&&(data=JSON.parse(error.message.replace("Internal JSON-RPC error.",""))),4001==error.code?infoPopup(Tokenico.lang.connectionRefused):"object"==typeof data&&data.message.includes("presale publish fee")||error.message.includes("presale publish fee")?errorPopup(Tokenico.lang.youDidintPay):errorPopup(Tokenico.lang.unexpectedError+" "+error.message)}}var networkName})})(jQuery);